"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleDocumentSymbol = exports.handleCodeActions = exports.handleCompletionResolveRequest = exports.handleRenameRequest = exports.handleCompletionRequest = exports.handleHoverRequest = exports.handleDocumentFormatting = exports.handleDefinitionRequest = exports.handleDiagnosticsRequest = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const format_1 = __importDefault(require("./prisma-schema-wasm/format"));
const lint_1 = __importDefault(require("./prisma-schema-wasm/lint"));
const code_actions_1 = require("./code-actions");
const rename_1 = require("./code-actions/rename");
const validations_1 = require("./validations");
const ast_1 = require("./ast");
const completions_1 = require("./completions");
const Schema_1 = require("./Schema");
function handleDiagnosticsRequest(document, onError) {
    const text = document.getText((0, ast_1.fullDocumentRange)(document));
    const res = (0, lint_1.default)(text, (errorMessage) => {
        if (onError) {
            onError(errorMessage);
        }
    });
    const diagnostics = [];
    if (res.some((diagnostic) => diagnostic.text === "Field declarations don't require a `:`." ||
        diagnostic.text === 'Model declarations have to be indicated with the `model` keyword.')) {
        if (onError) {
            onError("You might currently be viewing a Prisma 1 datamodel which is based on the GraphQL syntax. The current Prisma Language Server doesn't support this syntax. If you are handling a Prisma 1 datamodel, please change the file extension to `.graphql` so the new Prisma Language Server does not get triggered anymore.");
        }
    }
    for (const diag of res) {
        const previewNotKnownRegex = /The preview feature \"[a-zA-Z]+\" is not known/;
        const diagnostic = {
            range: {
                start: document.positionAt(diag.start),
                end: document.positionAt(diag.end),
            },
            message: previewNotKnownRegex.test(diag.text)
                ? `${diag.text}.\nIf this is unexpected, it might be due to your Prisma VS Code Extension being out of date.`
                : diag.text,
            source: 'Prisma',
        };
        if (diag.is_warning) {
            diagnostic.severity = vscode_languageserver_1.DiagnosticSeverity.Warning;
        }
        else {
            diagnostic.severity = vscode_languageserver_1.DiagnosticSeverity.Error;
        }
        diagnostics.push(diagnostic);
    }
    (0, validations_1.validateExperimentalFeatures)(document, diagnostics);
    const schema = Schema_1.PrismaSchema.singleFile(document);
    (0, validations_1.validateIgnoredBlocks)(schema, diagnostics);
    return diagnostics;
}
exports.handleDiagnosticsRequest = handleDiagnosticsRequest;
/**
 * @todo Use official schema.prisma parser. This is a workaround!
 */
function handleDefinitionRequest(document, params) {
    const position = params.position;
    const schema = Schema_1.PrismaSchema.singleFile(document);
    const word = (0, ast_1.getWordAtPosition)(document, position);
    if (word === '') {
        return;
    }
    // get start position of block
    const results = schema
        .linesAsArray()
        .map(({ document, lineIndex, text }) => {
        if ((text.includes('model') && text.includes(word)) ||
            (text.includes('type') && text.includes(word)) ||
            (text.includes('enum') && text.includes(word))) {
            return [document, lineIndex];
        }
    })
        .filter((result) => result !== undefined);
    if (results.length === 0) {
        return;
    }
    const foundBlocks = results
        .map(([document, lineNo]) => {
        const block = (0, ast_1.getBlockAtPosition)(document.uri, lineNo, schema);
        if (block && block.name === word && block.range.start.line === lineNo) {
            return block;
        }
    })
        .filter((block) => block !== undefined);
    if (foundBlocks.length !== 1) {
        return;
    }
    if (!foundBlocks[0]) {
        return;
    }
    return [
        {
            targetUri: foundBlocks[0].definingDocument.uri,
            targetRange: foundBlocks[0].range,
            targetSelectionRange: foundBlocks[0].nameRange,
        },
    ];
}
exports.handleDefinitionRequest = handleDefinitionRequest;
/**
 * This handler provides the modification to the document to be formatted.
 */
function handleDocumentFormatting(params, document, onError) {
    const formatted = (0, format_1.default)(document.getText(), params, onError);
    return [vscode_languageserver_1.TextEdit.replace((0, ast_1.fullDocumentRange)(document), formatted)];
}
exports.handleDocumentFormatting = handleDocumentFormatting;
function handleHoverRequest(document, params) {
    const position = params.position;
    const schema = Schema_1.PrismaSchema.singleFile(document);
    const word = (0, ast_1.getWordAtPosition)(document, position);
    if (word === '') {
        return;
    }
    const block = (0, ast_1.getDatamodelBlock)(word, schema);
    if (!block) {
        return;
    }
    const blockDocumentation = (0, ast_1.getDocumentationForBlock)(document, block);
    if (blockDocumentation.length !== 0) {
        return {
            contents: blockDocumentation.join('\n\n'),
        };
    }
    // TODO uncomment once https://github.com/prisma/prisma/issues/2546 is resolved!
    /*if (docComments.startsWith('//')) {
      return {
        contents: docComments.slice(3).trim(),
      }
    } */
    return;
}
exports.handleHoverRequest = handleHoverRequest;
/**
 *
 * This handler provides the initial list of the completion items.
 */
function handleCompletionRequest(params, document, onError) {
    return (0, completions_1.prismaSchemaWasmCompletions)(params, document, onError) || (0, completions_1.localCompletions)(params, document, onError);
}
exports.handleCompletionRequest = handleCompletionRequest;
function handleRenameRequest(params, document) {
    const schema = Schema_1.PrismaSchema.singleFile(document);
    const schemaLines = schema.linesAsArray();
    const position = params.position;
    const block = (0, ast_1.getBlockAtPosition)(document.uri, position.line, schema);
    if (!block) {
        return undefined;
    }
    const currentLine = block.definingDocument.lines[params.position.line].text;
    const isDatamodelBlockRename = (0, rename_1.isDatamodelBlockName)(position, block, schema, document);
    const isMappable = ['model', 'enum', 'view'].includes(block.type);
    const needsMap = !isDatamodelBlockRename ? true : isMappable;
    const isEnumValueRename = (0, rename_1.isEnumValue)(currentLine, params.position, block, document);
    const isValidFieldRename = (0, rename_1.isValidFieldName)(currentLine, params.position, block, document);
    const isRelationFieldRename = isValidFieldRename && (0, rename_1.isRelationField)(currentLine, schema);
    if (isDatamodelBlockRename || isEnumValueRename || isValidFieldRename) {
        const edits = [];
        const currentName = (0, rename_1.extractCurrentName)(currentLine, isDatamodelBlockRename, isEnumValueRename, isValidFieldRename, document, params.position);
        let lineNumberOfDefinition = position.line;
        let blockOfDefinition = block;
        let lineOfDefinitionContent = currentLine;
        if (isDatamodelBlockRename) {
            // get definition of model or enum
            const matchBlockBeginning = new RegExp(`\\s*(${block.type})\\s+(${currentName})\\s*({)`, 'g');
            const lineOfDefinition = schemaLines.find((line) => matchBlockBeginning.test(line.text));
            if (!lineOfDefinition) {
                return;
            }
            const { document: definitionDoc, lineIndex, text } = lineOfDefinition;
            lineNumberOfDefinition = lineIndex;
            lineOfDefinitionContent = text;
            const definitionBlockAtPosition = (0, ast_1.getBlockAtPosition)(definitionDoc.uri, lineNumberOfDefinition, schema);
            if (!definitionBlockAtPosition) {
                return;
            }
            blockOfDefinition = definitionBlockAtPosition;
        }
        // rename marked string
        edits.push((0, rename_1.insertBasicRename)(params.newName, currentName, document, lineNumberOfDefinition));
        // check if map exists already
        if (!isRelationFieldRename &&
            !(0, rename_1.mapExistsAlready)(lineOfDefinitionContent, schema, blockOfDefinition, isDatamodelBlockRename) &&
            needsMap) {
            // add map attribute
            edits.push((0, rename_1.insertMapAttribute)(currentName, position, blockOfDefinition, isDatamodelBlockRename));
        }
        // rename references
        if (isDatamodelBlockRename) {
            edits.push((0, rename_1.renameReferencesForModelName)(currentName, params.newName, schema));
        }
        else if (isEnumValueRename) {
            edits.push((0, rename_1.renameReferencesForEnumValue)(currentName, params.newName, schema, blockOfDefinition.name));
        }
        else if (isValidFieldRename) {
            edits.push((0, rename_1.renameReferencesForFieldName)(currentName, params.newName, schema, blockOfDefinition, isRelationFieldRename));
        }
        (0, rename_1.printLogMessage)(currentName, params.newName, isDatamodelBlockRename, isValidFieldRename, isEnumValueRename, block.type);
        return {
            changes: (0, rename_1.mergeEditMaps)(edits),
        };
    }
    return;
}
exports.handleRenameRequest = handleRenameRequest;
/**
 *
 * @param item This handler resolves additional information for the item selected in the completion list.
 */
function handleCompletionResolveRequest(item) {
    return item;
}
exports.handleCompletionResolveRequest = handleCompletionResolveRequest;
function handleCodeActions(params, document, onError) {
    if (!params.context.diagnostics.length) {
        return [];
    }
    return (0, code_actions_1.quickFix)(document, params, onError);
}
exports.handleCodeActions = handleCodeActions;
function handleDocumentSymbol(params, document) {
    const schema = Schema_1.PrismaSchema.singleFile(document);
    return Array.from((0, ast_1.getBlocks)(schema), (block) => ({
        kind: {
            model: vscode_languageserver_1.SymbolKind.Class,
            enum: vscode_languageserver_1.SymbolKind.Enum,
            type: vscode_languageserver_1.SymbolKind.Interface,
            view: vscode_languageserver_1.SymbolKind.Class,
            datasource: vscode_languageserver_1.SymbolKind.Struct,
            generator: vscode_languageserver_1.SymbolKind.Function,
        }[block.type],
        name: block.name,
        range: block.range,
        selectionRange: block.nameRange,
    }));
}
exports.handleDocumentSymbol = handleDocumentSymbol;
//# sourceMappingURL=MessageHandler.js.map